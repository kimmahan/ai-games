<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 600">
  <defs>
    <radialGradient id="container-gradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#ffffff" />
      <stop offset="100%" stop-color="#f0f0f0" />
    </radialGradient>
    
    <!-- Ball gradients with different colors -->
    <radialGradient id="ball-gradient-1" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#ff9999" />
      <stop offset="100%" stop-color="#ff3333" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-2" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#99ff99" />
      <stop offset="100%" stop-color="#33ff33" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-3" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#9999ff" />
      <stop offset="100%" stop-color="#3333ff" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-4" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#ffff99" />
      <stop offset="100%" stop-color="#ffff33" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-5" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#ff99ff" />
      <stop offset="100%" stop-color="#ff33ff" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-6" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#99ffff" />
      <stop offset="100%" stop-color="#33ffff" />
    </radialGradient>
    
    <radialGradient id="ball-gradient-7" cx="30%" cy="30%" r="70%" fx="30%" fy="30%">
      <stop offset="0%" stop-color="#ffcc99" />
      <stop offset="100%" stop-color="#ff9933" />
    </radialGradient>
    
    <!-- Add subtle shadow filter -->
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="3" />
      <feOffset dx="2" dy="2" result="offsetblur" />
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.3" />
      </feComponentTransfer>
      <feMerge>
        <feMergeNode />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
  </defs>
  
  <!-- Container circle -->
  <circle cx="300" cy="300" r="290" fill="url(#container-gradient)" stroke="#ddd" stroke-width="2" />
  
  <!-- Balls -->
  <g id="balls">
    <!-- Balls will be generated by the script -->
  </g>
  
  <script type="text/javascript"><![CDATA[
    // Configuration
    const numBalls = 100;
    const containerRadius = 290;
    const containerCenterX = 300;
    const containerCenterY = 300;
    const minBallRadius = 5;
    const maxBallRadius = 15;
    const minSpeed = 1;
    const maxSpeed = 3;
    const gradients = [
      "url(#ball-gradient-1)",
      "url(#ball-gradient-2)",
      "url(#ball-gradient-3)",
      "url(#ball-gradient-4)",
      "url(#ball-gradient-5)",
      "url(#ball-gradient-6)",
      "url(#ball-gradient-7)"
    ];
    
    // Ball class
    class Ball {
      constructor() {
        this.radius = minBallRadius + Math.random() * (maxBallRadius - minBallRadius);
        
        // Ensure ball starts within container with some padding based on its radius
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * (containerRadius - this.radius - 10);
        this.x = containerCenterX + Math.cos(angle) * distance;
        this.y = containerCenterY + Math.sin(angle) * distance;
        
        // Random velocity but ensure it's not too slow
        const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);
        const direction = Math.random() * Math.PI * 2;
        this.vx = Math.cos(direction) * speed;
        this.vy = Math.sin(direction) * speed;
        
        // Random gradient
        this.fill = gradients[Math.floor(Math.random() * gradients.length)];
        
        // Create the SVG element
        this.element = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this.element.setAttribute("cx", this.x);
        this.element.setAttribute("cy", this.y);
        this.element.setAttribute("r", this.radius);
        this.element.setAttribute("fill", this.fill);
        this.element.setAttribute("filter", "url(#shadow)");
        
        // Add to the SVG
        document.getElementById("balls").appendChild(this.element);
      }
      
      update() {
        // Update position
        this.x += this.vx;
        this.y += this.vy;
        
        // Check collision with container
        const dx = this.x - containerCenterX;
        const dy = this.y - containerCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance + this.radius > containerRadius) {
          // Normalize direction vector
          const nx = dx / distance;
          const ny = dy / distance;
          
          // Set position to the boundary minus a small epsilon to avoid sticking
          const correctionDistance = containerRadius - this.radius - 0.1;
          this.x = containerCenterX + nx * correctionDistance;
          this.y = containerCenterY + ny * correctionDistance;
          
          // Reflect velocity vector across normal
          const dot = this.vx * nx + this.vy * ny;
          this.vx = this.vx - 2 * dot * nx;
          this.vy = this.vy - 2 * dot * ny;
          
          // Add a little randomness on bounce
          this.vx += (Math.random() - 0.5) * 0.3;
          this.vy += (Math.random() - 0.5) * 0.3;
        }
        
        // Update element
        this.element.setAttribute("cx", this.x);
        this.element.setAttribute("cy", this.y);
      }
    }
    
    // Create balls
    const balls = [];
    for (let i = 0; i < numBalls; i++) {
      balls.push(new Ball());
    }
    
    // Animation loop
    function animate() {
      // Update each ball
      for (const ball of balls) {
        ball.update();
      }
      
      // Continue animation
      requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
  ]]></script>
</svg>